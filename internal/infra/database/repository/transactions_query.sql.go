// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions_query.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (
	transaction_id,
	code, 
	account_id,
	account_category_id, 
	amount,
	description, 
	date,
	added_by
) VALUES (
	$1, $2, $3, $4, $5, $6, $7, $8
)
`

type CreateTransactionParams struct {
	TransactionID     uuid.UUID  `json:"transaction_id"`
	Code              string     `json:"code"`
	AccountID         *uuid.UUID `json:"account_id"`
	AccountCategoryID *uuid.UUID `json:"account_category_id"`
	Amount            int32      `json:"amount"`
	Description       *string    `json:"description"`
	Date              time.Time  `json:"date"`
	AddedBy           *uuid.UUID `json:"added_by"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.Exec(ctx, createTransaction,
		arg.TransactionID,
		arg.Code,
		arg.AccountID,
		arg.AccountCategoryID,
		arg.Amount,
		arg.Description,
		arg.Date,
		arg.AddedBy,
	)
	return err
}

const findLastTransactionCode = `-- name: FindLastTransactionCode :one
SELECT code FROM transactions WHERE account_id = $1 ORDER BY code DESC LIMIT 1
`

func (q *Queries) FindLastTransactionCode(ctx context.Context, accountID *uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, findLastTransactionCode, accountID)
	var code string
	err := row.Scan(&code)
	return code, err
}

const findTransactionById = `-- name: FindTransactionById :one
SELECT 
	t.code as transaction_code, 
	ac.category_code AS category_code,
	c.name AS category_name,
	c.type AS category_type,
	t.date as transaction_date,
	t.amount, 
	t.description, 
	t.created_at
FROM transactions t
LEFT JOIN account_categories ac ON 
	t.account_category_id = ac.account_category_id
LEFT JOIN categories c ON 
	ac.category_id = c.category_id
WHERE transaction_id = $1
`

type FindTransactionByIdRow struct {
	TransactionCode string    `json:"transaction_code"`
	CategoryCode    *string   `json:"category_code"`
	CategoryName    *string   `json:"category_name"`
	CategoryType    *string   `json:"category_type"`
	TransactionDate time.Time `json:"transaction_date"`
	Amount          int32     `json:"amount"`
	Description     *string   `json:"description"`
	CreatedAt       time.Time `json:"created_at"`
}

func (q *Queries) FindTransactionById(ctx context.Context, transactionID uuid.UUID) (FindTransactionByIdRow, error) {
	row := q.db.QueryRow(ctx, findTransactionById, transactionID)
	var i FindTransactionByIdRow
	err := row.Scan(
		&i.TransactionCode,
		&i.CategoryCode,
		&i.CategoryName,
		&i.CategoryType,
		&i.TransactionDate,
		&i.Amount,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const findTransactions = `-- name: FindTransactions :many
SELECT 
	t.code as transaction_code, 
	ac.category_code AS category_code,
	ac.color as category_color,
	c.name AS category_name,
	c.type AS category_type,
	t.date as transaction_date,
	t.amount, 
	t.description,
	u.name as added_by,
	t.created_at 
FROM transactions t 
LEFT JOIN account_categories ac ON 
	t.account_category_id = ac.account_category_id 
LEFT JOIN categories c ON 
	ac.category_id = c.category_id 
LEFT JOIN users u ON u.user_id = t.added_by 
WHERE 
	t.account_id = $1
		AND t.deleted_at IS NULL
		AND c.type = COALESCE(NULLIF($2::text, ''), c.type)
		AND (t.added_by = $3 OR $3 IS NULL)
		AND (t.date BETWEEN $4 AND $5 OR ($4 IS NULL AND $5 IS NULL))
ORDER BY 
		c.name ASC,
		t.date DESC
`

type FindTransactionsParams struct {
	AccountID *uuid.UUID `json:"account_id"`
	Type      *string    `json:"type"`
	AddedBy   *uuid.UUID `json:"added_by"`
	From      time.Time  `json:"from"`
	To        time.Time  `json:"to"`
}

type FindTransactionsRow struct {
	TransactionCode string    `json:"transaction_code"`
	CategoryCode    *string   `json:"category_code"`
	CategoryColor   *string   `json:"category_color"`
	CategoryName    *string   `json:"category_name"`
	CategoryType    *string   `json:"category_type"`
	TransactionDate time.Time `json:"transaction_date"`
	Amount          int32     `json:"amount"`
	Description     *string   `json:"description"`
	AddedBy         *string   `json:"added_by"`
	CreatedAt       time.Time `json:"created_at"`
}

func (q *Queries) FindTransactions(ctx context.Context, arg FindTransactionsParams) ([]FindTransactionsRow, error) {
	rows, err := q.db.Query(ctx, findTransactions,
		arg.AccountID,
		arg.Type,
		arg.AddedBy,
		arg.From,
		arg.To,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindTransactionsRow
	for rows.Next() {
		var i FindTransactionsRow
		if err := rows.Scan(
			&i.TransactionCode,
			&i.CategoryCode,
			&i.CategoryColor,
			&i.CategoryName,
			&i.CategoryType,
			&i.TransactionDate,
			&i.Amount,
			&i.Description,
			&i.AddedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTransactionsByType = `-- name: FindTransactionsByType :many
SELECT 
	c.name,
  t.amount, 
	t.description, 
	t.date as transaction_date 
FROM transactions t
LEFT JOIN account_categories ac ON ac.account_category_id = t.account_category_id
LEFT JOIN categories c ON c.category_id = ac.category_id
WHERE 
	t.account_id = $1
	AND c.type = $2
	AND t.date BETWEEN $3 AND $4
ORDER BY 
    c.name ASC,
    t.date ASC
`

type FindTransactionsByTypeParams struct {
	AccountID *uuid.UUID `json:"account_id"`
	Type      string     `json:"type"`
	From      time.Time  `json:"from"`
	To        time.Time  `json:"to"`
}

type FindTransactionsByTypeRow struct {
	Name            *string   `json:"name"`
	Amount          int32     `json:"amount"`
	Description     *string   `json:"description"`
	TransactionDate time.Time `json:"transaction_date"`
}

func (q *Queries) FindTransactionsByType(ctx context.Context, arg FindTransactionsByTypeParams) ([]FindTransactionsByTypeRow, error) {
	rows, err := q.db.Query(ctx, findTransactionsByType,
		arg.AccountID,
		arg.Type,
		arg.From,
		arg.To,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindTransactionsByTypeRow
	for rows.Next() {
		var i FindTransactionsByTypeRow
		if err := rows.Scan(
			&i.Name,
			&i.Amount,
			&i.Description,
			&i.TransactionDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
