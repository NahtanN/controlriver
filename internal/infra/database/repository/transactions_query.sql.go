// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions_query.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (
	transaction_id,
	transaction_code, 
	account_id,
	category_id, 
	amount,
	description, 
	transaction_date
) VALUES (
	$1, $2, $3, $4, $5, $6, $7
)
`

type CreateTransactionParams struct {
	TransactionID   uuid.UUID  `json:"transaction_id"`
	TransactionCode string     `json:"transaction_code"`
	AccountID       *uuid.UUID `json:"account_id"`
	CategoryID      *uuid.UUID `json:"category_id"`
	Amount          int32      `json:"amount"`
	Description     *string    `json:"description"`
	TransactionDate time.Time  `json:"transaction_date"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.Exec(ctx, createTransaction,
		arg.TransactionID,
		arg.TransactionCode,
		arg.AccountID,
		arg.CategoryID,
		arg.Amount,
		arg.Description,
		arg.TransactionDate,
	)
	return err
}

const findLastTransactionCode = `-- name: FindLastTransactionCode :one
SELECT transaction_code FROM transactions WHERE account_id = $1 ORDER BY transaction_code DESC LIMIT 1
`

func (q *Queries) FindLastTransactionCode(ctx context.Context, accountID *uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, findLastTransactionCode, accountID)
	var transaction_code string
	err := row.Scan(&transaction_code)
	return transaction_code, err
}

const findTransactionById = `-- name: FindTransactionById :one
SELECT 
	t.transaction_code, 
	ac.category_code AS category_code,
	c.name AS category_name,
	c.type AS category_type,
	t.transaction_date,
	t.amount, 
	t.description, 
	t.created_at
FROM transactions t
LEFT JOIN account_categories ac ON 
	t.category_id = ac.category_id
LEFT JOIN categories c ON 
	ac.category_id = c.category_id
WHERE transaction_id = $1
`

type FindTransactionByIdRow struct {
	TransactionCode string    `json:"transaction_code"`
	CategoryCode    *string   `json:"category_code"`
	CategoryName    *string   `json:"category_name"`
	CategoryType    *string   `json:"category_type"`
	TransactionDate time.Time `json:"transaction_date"`
	Amount          int32     `json:"amount"`
	Description     *string   `json:"description"`
	CreatedAt       time.Time `json:"created_at"`
}

func (q *Queries) FindTransactionById(ctx context.Context, transactionID uuid.UUID) (FindTransactionByIdRow, error) {
	row := q.db.QueryRow(ctx, findTransactionById, transactionID)
	var i FindTransactionByIdRow
	err := row.Scan(
		&i.TransactionCode,
		&i.CategoryCode,
		&i.CategoryName,
		&i.CategoryType,
		&i.TransactionDate,
		&i.Amount,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const findTransactionsByType = `-- name: FindTransactionsByType :many
SELECT 
	c.name,
  t.amount, 
	t.description, 
	t.transaction_date 
FROM transactions t
LEFT JOIN account_categories ac ON ac.account_category_id = t.category_id
LEFT JOIN categories c ON c.category_id = ac.category_id
WHERE 
	t.account_id = $1
	AND c.type = $2
	AND t.transaction_date BETWEEN $3 AND $4
ORDER BY 
    c.name ASC,
    t.transaction_date ASC
`

type FindTransactionsByTypeParams struct {
	AccountID *uuid.UUID `json:"account_id"`
	Type      string     `json:"type"`
	From      time.Time  `json:"from"`
	To        time.Time  `json:"to"`
}

type FindTransactionsByTypeRow struct {
	Name            *string   `json:"name"`
	Amount          int32     `json:"amount"`
	Description     *string   `json:"description"`
	TransactionDate time.Time `json:"transaction_date"`
}

func (q *Queries) FindTransactionsByType(ctx context.Context, arg FindTransactionsByTypeParams) ([]FindTransactionsByTypeRow, error) {
	rows, err := q.db.Query(ctx, findTransactionsByType,
		arg.AccountID,
		arg.Type,
		arg.From,
		arg.To,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindTransactionsByTypeRow
	for rows.Next() {
		var i FindTransactionsByTypeRow
		if err := rows.Scan(
			&i.Name,
			&i.Amount,
			&i.Description,
			&i.TransactionDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
